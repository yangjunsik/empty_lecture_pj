# -*- coding: utf-8 -*-
"""12ìƒ‰ì¡°_ì‚¬ìš©&ì˜ˆì•½ 1ì°¨

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r6TNPmGU92NsZGdjaP3Po1KPSTPnNMmJ

- ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„¤ì¹˜
"""

!pip install fastapi uvicorn nest-asyncio pyngrok

!apt install tesseract-ocr

!pip install pytesseract pillow fastapi uvicorn nest-asyncio pyngrok

!pip install python-jose[cryptography]

!pip install python-multipart

!pip install python-dotenv

from fastapi import FastAPI
from fastapi import HTTPException, Depends, Header
from fastapi.openapi.utils import get_openapi
from fastapi.openapi.models import APIKey, APIKeyIn, SecuritySchemeType
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi import UploadFile, File
from fastapi.responses import JSONResponse
from fastapi import Depends

from jose import JWTError
from jose import  jwt

from dotenv import load_dotenv

import os

from pydantic import BaseModel

from datetime import datetime, timedelta
security = HTTPBearer()

import sqlite3

import shutil

import os
from fastapi import FastAPI, UploadFile, File #ì‚¬ì§„

from PIL import Image
import pytesseract

from io import BytesIO

from typing import Optional

from PIL import Image

import pytesseract

from io import BytesIO
import sqlite3

app = FastAPI()

"""# JMT í•¨ìˆ˜"""

with open(".env", "w") as f:
    f.write("SECRET_KEY=my-super-secret-key")

#ì„ì˜ë¡œ ã„±

load_dotenv()

SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = "HS256"

print(SECRET_KEY)

def decode_token(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload.get("sub")
    except JWTError:
        raise HTTPException(status_code=401, detail="í† í°ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")

"""# ë³´ì•ˆ"""

from fastapi.openapi.utils import get_openapi

def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema

    openapi_schema = get_openapi(
        title="ë¹ˆê°•ì˜ì‹¤ ê´€ë¦¬ ì‹œìŠ¤í…œ",
        version="1.0.0",
        description="JWT ì¸ì¦ í¬í•¨ Swagger ë¬¸ì„œ",
        routes=app.routes,
    )
    openapi_schema["components"]["securitySchemes"] = {
        "BearerAuth": {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT"
        }
    }
    for path in openapi_schema["paths"].values():
        for operation in path.values():
            operation["security"] = [{"BearerAuth": []}]
    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi

"""# ì‚¬ìš©ì í† í°"""

def create_token(user_id: str):
    payload = {
        "sub": user_id,
        "exp": datetime.utcnow() + timedelta(hours=1)
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

print(create_token("user1"))

@app.post("/reserve/{id}/use-file")
def use_reservation_file(
    id: int,
    file: UploadFile = File(...),
    authorization: str = Header(...)
):
    token = authorization.split(" ")[1]
    user_id = decode_token(token)

    reservation = user_reservations.get(id)
    if not reservation or reservation["user_id"] != user_id:
        raise HTTPException(status_code=403, detail="ì ‘ê·¼ ê¶Œí•œ ì—†ìŒ")

"""# ì˜ˆì•½ í˜„í™©

### ì˜ˆì•½ ëª©ë¡
"""

class ReservationResponse(BaseModel):
    room_id: int
    time: str
    status: str

@app.get("/my-reservations", response_model=list[ReservationResponse])
def get_my_reservations():
    return [
        {"room_id": 301, "time": "10:00", "status": "reserved"},
        {"room_id": 302, "time": "13:00", "status": "in_use"}
    ]

"""### ì‚¬ìš© ì¤‘ ì¸ì¦"""

class PhotoAuth(BaseModel):
    photo_url: str

@app.post("/reserve/{id}/use-url")
def use_reservation_url(id: int, data: PhotoAuth):
    return {"message": f"ì˜ˆì•½ {id}ë²ˆ ì‚¬ìš© ì¸ì¦ ì™„ë£Œ", "photo": data.photo_url}

{
  "photo_url": "https://image.com/photo.png"
}

"""### ì˜ˆì•½ ì·¨ì†Œ"""

@app.delete("/reserve/{id}")
def cancel_reservation(id: int):
    return {"message": f"ì˜ˆì•½ {id}ë²ˆ ì·¨ì†Œ ì™„ë£Œ"}

"""# ì‚¬ìš© í˜„í™©

### ë‚´ ë“±ê¸‰
"""

@app.get("/my-grade")
def get_grade(user_id: str = "user1"):
    return {"user_id": user_id, "grade": 87}

"""### ë‚¨ì€ ì‹œê°„"""

@app.get("/my-usage-time")
def get_usage_time(authorization: str = Header(...)):
    try:
        token = authorization.split(" ")[1]
        user_id = decode_token(token)

        conn = sqlite3.connect("reservations.db")
        cursor = conn.cursor()
        cursor.execute("""
            SELECT start_time, end_time
            FROM reservations
            WHERE user_id = ?
            ORDER BY id DESC
            LIMIT 1
        """, (user_id,))
        row = cursor.fetchone()
        conn.close()

        if not row or not row[0] or not row[1]:
            raise HTTPException(
                status_code=500,
                detail=f"ì˜ˆì•½ ì •ë³´ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ. row: {row}"
            )


        start_time = datetime.fromisoformat(row[0])
        end_time = datetime.fromisoformat(row[1])
        now = datetime.now()

        minutes_left = max(int((end_time - now).total_seconds() // 60), 0)

        return {
            "start_time": start_time.isoformat(),
            "end_time": end_time.isoformat(),
            "minutes_left": minutes_left
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"ì„œë²„ ì˜¤ë¥˜: {str(e)}")

"""# ì‚¬ì§„ì—…ë¡œë“œ"""

@app.post("/reserve/{id}/use")
def use_reservation(id: int, authorization: str = Header(...)):
    token = authorization.split(" ")[1]
    user_id = decode_token(token)

    reservation = user_reservations.get(id)
    if not reservation or reservation["user_id"] != user_id:
        raise HTTPException(status_code=403, detail="ì˜ˆì•½ ì •ë³´ ì—†ìŒ ë˜ëŠ” ê¶Œí•œ ì—†ìŒ")

    reservation["status"] = "in_use"

    return {
        "message": "ì‚¬ìš© ìƒíƒœë¡œ ì „í™˜ë¨",
        "room_id": reservation["room_id"]
    }

"""# ì‚¬ìš©ì‹œê°„ API"""

def get_active_reservation(user_id: str):
    conn = sqlite3.connect("reservations.db")
    cursor = conn.cursor()
    cursor.execute("""
        SELECT start_time, end_time
        FROM reservations
        WHERE user_id = ? AND status = 'in_use'
    """, (user_id,))
    row = cursor.fetchone()
    conn.close()
    return row

@app.get("/my-usage-time")
def get_usage_time(authorization: str = Header(...)):
    token = authorization.split(" ")[1]
    user_id = decode_token(token)

    row = get_active_reservation(user_id)
    if not row:
        raise HTTPException(status_code=404, detail="ì‚¬ìš© ì¤‘ì¸ ì˜ˆì•½ì´ ì—†ìŠµë‹ˆë‹¤.")

    start_time_str, end_time_str = row
    start_time = datetime.fromisoformat(start_time_str)
    end_time = datetime.fromisoformat(end_time_str)
    now = datetime.now()

    minutes_left = max(int((end_time - now).total_seconds() // 60), 0)

    return {
        "start_time": start_time.isoformat(),
        "end_time": end_time.isoformat(),
        "minutes_left": minutes_left
    }

"""# í‡´ì‹¤ ì²˜ë¦¬"""

@app.post("/reserve/{id}/exit")
def exit_reservation(id: int, authorization: str = Header(...)):
    token = authorization.split(" ")[1]
    user_id = decode_token(token)

    reservation = user_reservations.get(id)
    if not reservation or reservation["user_id"] != user_id:
        raise HTTPException(status_code=403, detail="ì˜ˆì•½ ì •ë³´ ì—†ìŒ ë˜ëŠ” ê¶Œí•œ ì—†ìŒ")

    now = datetime.now()
    end_time = datetime.fromisoformat(reservation["end_time"])
    used_minutes = int((now - datetime.fromisoformat(reservation["start_time"])).total_seconds() // 60)

    reservation["status"] = "exited"

    return {
        "message": "í‡´ì‹¤ ì™„ë£Œ",
        "used_minutes": used_minutes,
        "room_id": reservation["room_id"]
    }

"""# ë“±ê¸‰API

# ì˜ˆì•½API

í”„ë¡ íŠ¸ í›„ í•˜ê¸°
"""



"""# SQLite

### DBìƒì„±
"""

import sqlite3

conn = sqlite3.connect("reservations.db")
cursor = conn.cursor()

cursor.execute("""
CREATE TABLE IF NOT EXISTS reservations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT,
    room_id INTEGER,
    status TEXT,
    start_time TEXT,
    end_time TEXT
)
""")

cursor.execute("""
INSERT INTO reservations (user_id, room_id, status, start_time, end_time)
VALUES ("user1", 302, "reserved", "2025-05-25T13:00", "2025-05-25T14:00")
""")

conn.commit()
conn.close()

"""### DBì¡°íšŒ"""

def get_reservation_from_db(reserve_id: int):
    conn = sqlite3.connect("reservations.db")
    cursor = conn.cursor()
    cursor.execute("SELECT user_id, room_id FROM reservations WHERE id = ?", (reserve_id,))
    row = cursor.fetchone()
    conn.close()

    if row:
        return {"user_id": row[0], "room_id": row[1]}
    else:
        return None

"""### ê¸°ì¡´APIìƒì„±"""

@app.post("/reserve/{id}/use")
async def use_reservation(
    id: int,
    file: UploadFile = File(...),
    authorization: str = Header(...)
):
    token = authorization.split(" ")[1]
    user_id = decode_token(token)

    reservation = get_reservation_from_db(id)
    if not reservation or reservation["user_id"] != user_id:
        raise HTTPException(status_code=403, detail="ì ‘ê·¼ ê¶Œí•œ ì—†ìŒ")

    image = Image.open(BytesIO(await file.read()))
    ocr_text = pytesseract.image_to_string(image)

    expected_room = str(reservation["room_id"])
    if expected_room not in ocr_text:
        raise HTTPException(status_code=400, detail="ì‚¬ì§„ì—ì„œ ê°•ì˜ì‹¤ ë²ˆí˜¸ë¥¼ í™•ì¸í•  ìˆ˜ ì—†ìŒ")

    return {"message": "ì¸ì¦ ì„±ê³µ", "room_number": expected_room}

"""# í…ŒìŠ¤íŠ¸ìš© JWT ìƒì„±ê¸°"""

!ngrok config add-authtoken "2xY2WVmlvhaDE3oxlQE4PbG0bnL_42qcjEv2FGLFfMZUaLTQP"

import threading

from pyngrok import ngrok
import uvicorn

def run_app():
    uvicorn.run(app, host="0.0.0.0", port=8000)

thread = threading.Thread(target=run_app)
thread.start()

public_url = ngrok.connect(8000)
print("ğŸ”— Swagger ì£¼ì†Œ:", public_url.public_url + "/docs")

"""# í…ŒìŠ¤íŠ¸ì…‹"""

user_reservations = {
    1: {
        "user_id": "user1",
        "room_id": 9,
        "start_time": "2025-05-25T10:00:00",
        "end_time": "2025-05-25T12:00:00",
        "status": "reserved"
    }
}

